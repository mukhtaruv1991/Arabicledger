==== ملفات المشروع الأساسية ====


==== package.json ====

{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:push": "npx drizzle-kit push"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@tanstack/react-query": "^5.60.5",
    "@types/memoizee": "^0.4.12",
    "bcryptjs": "^2.4.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "date-fns": "^3.6.0",
    "drizzle-kit": "^0.30.4",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "framer-motion": "^11.13.1",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.453.0",
    "memoizee": "^0.4.17",
    "memorystore": "^1.6.7",
    "next-themes": "^0.4.6",
    "openid-client": "^6.6.2",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "passport-local": "^1.0.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.55.0",
    "react-icons": "^5.4.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.2",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.2.5",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.24.2",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.2.8",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@tailwindcss/vite": "^4.1.3",
    "@types/bcryptjs": "^2.4.6",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-google-oauth20": "^2.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.19"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}


==== railway.json ====
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "NIXPACKS"
  },
  "deploy": {
    "startCommand": "npm start",
    "healthcheckPath": "/",
    "healthcheckTimeout": 300,
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
}

==== server/index.ts ====
import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";

const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: false }));

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "…";
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  const server = await registerRoutes(app);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    res.status(status).json({ message });
    throw err;
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  // ALWAYS serve the app on the port specified in the environment variable PORT
  // Other ports are firewalled. Default to 5000 if not specified.
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  const port = parseInt(process.env.PORT || '5000', 10);
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true,
  }, () => {
    log(`serving on port ${port}`);
  });
})();


==== server/routes.ts ====
// المحتوى الكامل لملف server/routes.ts
import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
// --- التعديل 1: استيراد نظام المصادقة المحلي الجديد ---
import { setupLocalAuth, isAuthenticated } from "./localAuth";
import { setupTelegramBot } from "./telegramBot";
import {
  insertCompanySchema,
  insertAccountSchema,
  insertJournalEntrySchema,
  insertJournalEntryDetailSchema,
  insertTelegramSettingsSchema,
} from "@shared/schema";
import { z } from "zod";

export async function registerRoutes(app: Express): Promise<Server> {
  // --- التعديل 2: تفعيل نظام المصادقة المحلي ---
  await setupLocalAuth(app);

  // Setup Telegram bot
  setupTelegramBot(app);

  // --- التعديل 3: مسار جديد للحصول على بيانات المستخدم المسجل دخوله ---
  // هذا المسار مهم جدًا للواجهة الأمامية لتعرف من هو المستخدم الحالي
  app.get('/api/auth/me', isAuthenticated, async (req: any, res) => {
    // req.user يأتي من passport بعد تسجيل الدخول بنجاح
    // لا نرسل كلمة المرور المشفرة أبدًا إلى الواجهة الأمامية
    const { hashedPassword, ...userWithoutPassword } = req.user;
    res.json(userWithoutPassword);
  });


  // --- كل المسارات التالية محمية الآن بواسطة isAuthenticated ---
  // --- وهي تستخدم الآن req.user.id من نظامنا المحلي ---

  // Company routes
  app.get('/api/companies', isAuthenticated, async (req: any, res) => {
    try {
      // ملاحظة: الحقل createdBy في جدول الشركات هو من نوع varchar
      // ومعرف المستخدم في جدول auth_users هو رقم. يجب تحويله إلى نص.
      const userId = req.user.id.toString();
      const companies = await storage.getCompanies(userId);
      res.json(companies);
    } catch (error) {
      console.error("Error fetching companies:", error);
      res.status(500).json({ message: "Failed to fetch companies" });
    }
  });

  app.get('/api/companies/:id', isAuthenticated, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      const company = await storage.getCompany(id);
      if (!company) {
        return res.status(404).json({ message: "Company not found" });
      }
      res.json(company);
    } catch (error) {
      console.error("Error fetching company:", error);
      res.status(500).json({ message: "Failed to fetch company" });
    }
  });

  app.post('/api/companies', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id.toString();
      const companyData = insertCompanySchema.parse({
        ...req.body,
        createdBy: userId,
      });
      const company = await storage.createCompany(companyData);
      res.status(201).json(company);
    } catch (error) {
      console.error("Error creating company:", error);
      res.status(500).json({ message: "Failed to create company" });
    }
  });

  app.put('/api/companies/:id', isAuthenticated, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      const companyData = insertCompanySchema.partial().parse(req.body);
      const company = await storage.updateCompany(id, companyData);
      res.json(company);
    } catch (error) {
      console.error("Error updating company:", error);
      res.status(500).json({ message: "Failed to update company" });
    }
  });

  app.delete('/api/companies/:id', isAuthenticated, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteCompany(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting company:", error);
      res.status(500).json({ message: "Failed to delete company" });
    }
  });

  // Account routes
  app.get('/api/companies/:companyId/accounts', isAuthenticated, async (req: any, res) => {
    try {
      const companyId = parseInt(req.params.companyId);
      const accounts = await storage.getAccounts(companyId);
      res.json(accounts);
    } catch (error) {
      console.error("Error fetching accounts:", error);
      res.status(500).json({ message: "Failed to fetch accounts" });
    }
  });

  app.get('/api/accounts/:id', isAuthenticated, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      const account = await storage.getAccount(id);
      if (!account) {
        return res.status(404).json({ message: "Account not found" });
      }
      res.json(account);
    } catch (error) {
      console.error("Error fetching account:", error);
      res.status(500).json({ message: "Failed to fetch account" });
    }
  });

  app.post('/api/accounts', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id.toString();
      const accountData = insertAccountSchema.parse({
        ...req.body,
        createdBy: userId,
      });
      
      const existingAccount = await storage.getAccountByCode(accountData.code, accountData.companyId);
      if (existingAccount) {
        return res.status(400).json({ message: "Account code already exists" });
      }

      const account = await storage.createAccount(accountData);
      res.status(201).json(account);
    } catch (error) {
      console.error("Error creating account:", error);
      res.status(500).json({ message: "Failed to create account" });
    }
  });

  app.put('/api/accounts/:id', isAuthenticated, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      const accountData = insertAccountSchema.partial().parse(req.body);
      const account = await storage.updateAccount(id, accountData);
      res.json(account);
    } catch (error) {
      console.error("Error updating account:", error);
      res.status(500).json({ message: "Failed to update account" });
    }
  });

  app.delete('/api/accounts/:id', isAuthenticated, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteAccount(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting account:", error);
      res.status(500).json({ message: "Failed to delete account" });
    }
  });

  // Journal Entry routes
  app.get('/api/companies/:companyId/journal-entries', isAuthenticated, async (req: any, res) => {
    try {
      const companyId = parseInt(req.params.companyId);
      const limit = req.query.limit ? parseInt(req.query.limit as string) : undefined;
      const entries = await storage.getJournalEntries(companyId, limit);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching journal entries:", error);
      res.status(500).json({ message: "Failed to fetch journal entries" });
    }
  });

  app.get('/api/journal-entries/:id', isAuthenticated, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      const entry = await storage.getJournalEntry(id);
      if (!entry) {
        return res.status(404).json({ message: "Journal entry not found" });
      }
      res.json(entry);
    } catch (error) {
      console.error("Error fetching journal entry:", error);
      res.status(500).json({ message: "Failed to fetch journal entry" });
    }
  });

  const journalEntryWithDetailsSchema = z.object({
    entry: insertJournalEntrySchema,
    details: z.array(insertJournalEntryDetailSchema),
  });

  app.post('/api/journal-entries', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id.toString();
      const { entry, details } = journalEntryWithDetailsSchema.parse(req.body);
      
      const totalDebit = details.reduce((sum, detail) => sum + Number(detail.debit || 0), 0);
      const totalCredit = details.reduce((sum, detail) => sum + Number(detail.credit || 0), 0);
      
      if (Math.abs(totalDebit - totalCredit) > 0.01) {
        return res.status(400).json({ message: "Total debits must equal total credits" });
      }

      const entryData = {
        ...entry,
        createdBy: userId,
        totalDebit: totalDebit.toString(),
        totalCredit: totalCredit.toString(),
      };

      const journalEntry = await storage.createJournalEntry(entryData, details);
      res.status(201).json(journalEntry);
    } catch (error) {
      console.error("Error creating journal entry:", error);
      res.status(500).json({ message: "Failed to create journal entry" });
    }
  });

  app.put('/api/journal-entries/:id', isAuthenticated, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      const { entry, details } = journalEntryWithDetailsSchema.parse(req.body);
      
      const totalDebit = details.reduce((sum, detail) => sum + Number(detail.debit || 0), 0);
      const totalCredit = details.reduce((sum, detail) => sum + Number(detail.credit || 0), 0);
      
      if (Math.abs(totalDebit - totalCredit) > 0.01) {
        return res.status(400).json({ message: "Total debits must equal total credits" });
      }

      const entryData = {
        ...entry,
        totalDebit: totalDebit.toString(),
        totalCredit: totalCredit.toString(),
      };

      const journalEntry = await storage.updateJournalEntry(id, entryData, details);
      res.json(journalEntry);
    } catch (error) {
      console.error("Error updating journal entry:", error);
      res.status(500).json({ message: "Failed to update journal entry" });
    }
  });

  app.delete('/api/journal-entries/:id', isAuthenticated, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteJournalEntry(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting journal entry:", error);
      res.status(500).json({ message: "Failed to delete journal entry" });
    }
  });

  // Financial summary routes
  app.get('/api/companies/:companyId/financial-summary', isAuthenticated, async (req: any, res) => {
    try {
      const companyId = parseInt(req.params.companyId);
      const summary = await storage.getFinancialSummary(companyId);
      res.json(summary);
    } catch (error) {
      console.error("Error fetching financial summary:", error);
      res.status(500).json({ message: "Failed to fetch financial summary" });
    }
  });

  app.get('/api/companies/:companyId/account-balances', isAuthenticated, async (req: any, res) => {
    try {
      const companyId = parseInt(req.params.companyId);
      const balances = await storage.getAccountBalances(companyId);
      res.json(balances);
    } catch (error) {
      console.error("Error fetching account balances:", error);
      res.status(500).json({ message: "Failed to fetch account balances" });
    }
  });

  // Telegram bot routes
  app.get('/api/companies/:companyId/telegram-settings', isAuthenticated, async (req: any, res) => {
    try {
      const companyId = parseInt(req.params.companyId);
      const settings = await storage.getTelegramSettings(companyId);
      res.json(settings || {});
    } catch (error) {
      console.error("Error fetching telegram settings:", error);
      res.status(500).json({ message: "Failed to fetch telegram settings" });
    }
  });

  app.post('/api/telegram-settings', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id.toString();
      const settingsData = insertTelegramSettingsSchema.parse({
        ...req.body,
        createdBy: userId,
      });
      const settings = await storage.upsertTelegramSettings(settingsData);
      res.json(settings);
    } catch (error) {
      console.error("Error saving telegram settings:", error);
      res.status(500).json({ message: "Failed to save telegram settings" });
    }
  });


  const httpServer = createServer(app);
  return httpServer;
}


==== server/localAuth.ts ====
// server/localAuth.ts

import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import bcrypt from "bcryptjs";
import type { Express, RequestHandler } from "express";
import { storage } from "./storage"; // سنحتاج إلى storage للتفاعل مع قاعدة البيانات
import { getSession } from "./replitAuth"; // سنعيد استخدام نفس إعدادات الجلسة

export async function setupLocalAuth(app: Express) {
  app.set("trust proxy", 1);
  app.use(getSession()); // نستخدم نفس إعدادات الجلسة
  app.use(passport.initialize());
  app.use(passport.session());

  // استراتيجية تسجيل الدخول
  passport.use(new LocalStrategy(
    {
      usernameField: 'login', // الحقل في الواجهة الأمامية سيحمل اسم 'login'
      passwordField: 'password'
    },
    async (login, password, done) => {
      try {
        // البحث عن المستخدم بالبريد أو اسم المستخدم أو الرقم
        const user = await storage.findAuthUserByLogin(login);
        if (!user) {
          return done(null, false, { message: 'Incorrect username or password.' });
        }

        // مقارنة كلمة المرور
        const isMatch = await bcrypt.compare(password, user.hashedPassword);
        if (!isMatch) {
          return done(null, false, { message: 'Incorrect username or password.' });
        }

        return done(null, user);
      } catch (err) {
        return done(err);
      }
    }
  ));

  // تخزين المستخدم في الجلسة
  passport.serializeUser((user: any, done) => {
    done(null, user.id);
  });

  // استرجاع المستخدم من الجلسة
  passport.deserializeUser(async (id: number, done) => {
    try {
      const user = await storage.findAuthUserById(id);
      done(null, user);
    } catch (err) {
      done(err);
    }
  });

  // --- مسارات API ---

  // مسار تسجيل حساب جديد
  app.post('/api/auth/signup', async (req, res, next) => {
    try {
      const { fullName, email, username, phone, password, role, organizationName, adminEmail } = req.body;

      // التحقق من أن المستخدم غير موجود
      const existingUser = await storage.findAuthUserByLogin(email) || await storage.findAuthUserByLogin(username);
      if (existingUser) {
        return res.status(400).json({ message: 'User already exists.' });
      }

      // تشفير كلمة المرور
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);

      // إنشاء المستخدم الجديد
      const newUser = await storage.createAuthUser({
        fullName,
        email,
        username,
        phone,
        hashedPassword,
        role,
        organizationName,
        adminEmail
      });

      // تسجيل دخول المستخدم الجديد تلقائيًا
      req.login(newUser, (err) => {
        if (err) { return next(err); }
        return res.status(201).json(newUser);
      });

    } catch (error) {
      next(error);
    }
  });

  // مسار تسجيل الدخول
  app.post('/api/auth/login', passport.authenticate('local'), (req, res) => {
    // إذا نجحت المصادقة، سيتم استدعاء هذا الجزء
    res.json(req.user);
  });

  // مسار تسجيل الخروج
  app.get("/api/logout", (req, res, next) => {
    req.logout((err) => {
      if (err) { return next(err); }
      res.status(200).json({ message: 'Logged out successfully' });
    });
  });
}

// Middleware للتحقق مما إذا كان المستخدم مسجلاً دخوله
export const isAuthenticated: RequestHandler = (req, res, next) => {
  if (req.isAuthenticated()) {
    return next();
  }
  res.status(401).json({ message: "Unauthorized" });
};


==== client/src/App.tsx ====
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { useAuth } from "@/hooks/useAuth";
import NotFound from "@/pages/not-found";
import Landing from "@/pages/landing";
import Dashboard from "@/pages/dashboard";
import ChartOfAccounts from "@/pages/chart-of-accounts";
import JournalEntries from "@/pages/journal-entries";
import FinancialReports from "@/pages/financial-reports";
import Companies from "@/pages/companies";
import Users from "@/pages/users";
import TelegramBot from "@/pages/telegram-bot";
import TelegramSettings from "@/pages/telegram-settings";

function Router() {
  const { isAuthenticated, isLoading } = useAuth();

  return (
    <Switch>
      {isLoading || !isAuthenticated ? (
        <Route path="/" component={Landing} />
      ) : (
        <>
          <Route path="/" component={Dashboard} />
          <Route path="/chart-of-accounts" component={ChartOfAccounts} />
          <Route path="/journal-entries" component={JournalEntries} />
          <Route path="/financial-reports" component={FinancialReports} />
          <Route path="/companies" component={Companies} />
          <Route path="/users" component={Users} />
          <Route path="/telegram-bot" component={TelegramBot} />
          <Route path="/telegram-settings" component={TelegramSettings} />
        </>
      )}
      <Route component={NotFound} />
    </Switch>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
        <div dir="rtl" className="font-arabic">
          <Toaster />
          <Router />
        </div>
      </TooltipProvider>
    </QueryClientProvider>
  );
}

export default App;


==== client/src/hooks/useAuth.ts ====
// المحتوى الكامل لملف client/src/hooks/useAuth.ts
import { useQuery } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";

// تعريف شكل بيانات المستخدم التي ستعود من الخادم
interface AuthUser {
  id: number;
  fullName: string;
  email: string;
  username: string;
  phone: string;
  role: 'user' | 'admin' | 'superadmin';
  organizationName?: string;
  adminEmail?: string;
}

export function useAuth() {
  const { data: user, isLoading, error } = useQuery<AuthUser>({
    queryKey: ["/api/auth/me"],
    queryFn: () => apiRequest("GET", "/api/auth/me"),
    retry: false,
    refetchOnWindowFocus: false,
  });

  return {
    user,
    isLoading,
    isAuthenticated: !!user && !error,
    error,
  };
}
